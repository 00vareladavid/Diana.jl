var documenterSearchIndex = {"docs":
[{"location":"client/#Client-1","page":"Client","title":"Client","text":"","category":"section"},{"location":"client/#","page":"Client","title":"Client","text":"Diana also provides a GraphQL client implementation.","category":"page"},{"location":"client/#Simple-query-1","page":"Client","title":"Simple query","text":"","category":"section"},{"location":"client/#","page":"Client","title":"Client","text":"using Diana\n\nquery = \"\"\"\n        {\n          neomatrix{\n            nombre\n            linkedin\n          }\n        }\n        \"\"\"\n\nr = Queryclient(\"https://neomatrix.herokuapp.com/graphql\",\n                query,\n                headers = Dict(\"header\" => \"value\"))\nr.Info.status == 200 && println(r.Data)","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"result:","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"{\n  \"data\":{\n    \"neomatrix\":{\n        \"nombre\":\"Acevedo Maldonado Josue\",\n        \"linkedin\":\"https://www.linkedin.com/in/acevedo-maldonado-josue/\"\n    }\n  }\n}","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"query = \"\"\"\n        query consulta {\n          neomatrix {\n            nombre\n            linkedin\n          }\n        }\n\n        query hola {\n          neomatrix {\n            nombre\n          }\n        }\n        \"\"\"\nr = Queryclient(\"https://neomatrix.herokuapp.com/graphql\",query,operationName=\"hola\")\nr.Info.status == 200 && println(r.Data)","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"result:","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"{\"data\":{\"neomatrix\":{\"nombre\":\"Acevedo Maldonado Josue\"}}}","category":"page"},{"location":"client/#Query-1","page":"Client","title":"Query","text":"","category":"section"},{"location":"client/#","page":"Client","title":"Client","text":"using Diana\n\nclient = GraphQLClient(\"https://api.graph.cool/simple/v1/movies\")\nclient.serverAuth(\"Bearer my-jwt-token\")\nclient.headers(Dict(\"header\"=>\"value\"))\n\nor\n\nclient = GraphQLClient(\"https://api.graph.cool/simple/v1/movies\",auth=\"Bearer my-jwt-token\",headers=Dict(\"header\"=>\"value\"))","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"query = \"\"\"\n        {\n          Movie(title: \"Inception\"){\n            actors{\n              name\n            }\n          }\n        }\n        \"\"\"\n\nr = client.Query(query)\nr.Info.status == 200 && println(r.Data)","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"result:","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"{\n  \"data\":{\n    \"Movie\":{\n      \"actors\":[\n        {\n          \"name\":\"Leonardo DiCaprio\"\n        },\n        {\n          \"name\":\"Ellen Page\"\n        },\n        {\n          \"name\":\"Tom Hardy\"\n        },\n        {\n          \"name\":\"Joseph Gordon-Levitt\"\n        },\n        {\n          \"name\":\"Marion Cotillard\"\n        }\n      ]\n    }\n  }\n}","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"query = \"\"\"\n        query getMovie(\\$title: String!) {\n          Movie(title:\\$title) {\n            releaseDate\n            actors {\n              name\n            }\n          }\n        }\n        \"\"\"\nr = client.Query(query, vars= Dict(\"title\" => \"Inception\"))\n\nprintln(r.Data)","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"query = \"\"\"\n        query consulta {\n          Movie(title: \"Inception\") {\n            actors{\n              name\n            }\n          }\n        }\n        query hola {\n          Movie(title: \"Inception\") {\n            actors{\n              name\n            }\n          }\n        }\n        \"\"\"\nr = client.Query(query, operationName = \"consulta\")\nr.Info.status == 200 && println(r.Data)","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"result:","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"{\"data\":{\"Movie\":{\"actors\":[{\"name\":\"Leonardo DiCaprio\"},{\"name\":\"Ellen Page\"},{\"name\":\"Tom Hardy\"},{\"name\":\"Joseph Gordon-Levitt\"},{\"name\":\"Marion Cotillard\"}]}}}","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"using Diana\ngithub_endpoint = \"https://api.github.com/graphql\"\ngithub_user = # GitHub handle\ngithub_token = # GitHub personal token\ngithub_header = Dict(\"User-Agent\" => github_user)\nclient = GraphQLClient(github_endpoint,\n                       auth = \"bearer $github_token\",\n                       headers = github_header)\nquery = \"\"\"\n        query A{\n          rateLimit {\n            cost\n            remaining\n            resetAt\n          }\n          repository(owner: \"JuliaLang\", name: \"Julia\") {\n            id\n          }\n        }\"\"\"\n\nr = client.Query(query, operationName = \"A\")\nr.Info.status == 200 && println(r.Data)","category":"page"},{"location":"client/#Change-serverUrl-1","page":"Client","title":"Change serverUrl","text":"","category":"section"},{"location":"client/#","page":"Client","title":"Client","text":"client.serverUrl(\"https://api.graph.cool/simple/v1/movies\")","category":"page"},{"location":"client/#Change-headers-1","page":"Client","title":"Change headers","text":"","category":"section"},{"location":"client/#","page":"Client","title":"Client","text":"client.headers(Dict(\"header\" => \"value\"))","category":"page"},{"location":"client/#Change-serverAuth-1","page":"Client","title":"Change serverAuth","text":"","category":"section"},{"location":"client/#","page":"Client","title":"Client","text":"client.serverAuth(\"Bearer my-jwt-token\")","category":"page"},{"location":"client/#Query-get-1","page":"Client","title":"Query get","text":"","category":"section"},{"location":"client/#","page":"Client","title":"Client","text":"query=\"https://neomatrix.herokuapp.com/graphql?query=%7B%0A%20%20neomatrix%7B%0A%20%20%20%20nombre%0A%20%20%20%20linkedin%0A%20%20%7D%0A%7D\"\nr = Queryclient(query)\nr.Info.status == 200 && println(r.Data)","category":"page"},{"location":"client/#Link-1","page":"Client","title":"Link","text":"","category":"section"},{"location":"client/#","page":"Client","title":"Client","text":"It is possible to get links to the graphql query editor","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"query = \"\"\"\n        {\n          neomatrix{\n            nombre\n            linkedin\n          }\n        }\n        \"\"\"\nr = Queryclient(\"https://neomatrix.herokuapp.com/graphql\",query,getlink=true)","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"result:","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"\"https://neomatrix.herokuapp.com/graphql?query=%7B%0A%20%20neomatrix%7B%0A%20%20%20%20nombre%0A%20%20%20%20linkedin%0A%20%20%7D%0A%7D%0A\"","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"or","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"r = client.Query(query, getlink = true)","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"result:","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"\"https://api.graph.cool/simple/v1/movies?query=%7B%0A%20%20Movie%28title%3A%20%22Inception%22%29%7B%0A%20%20%20%20actors%7B%0A%20%20%20%20%20%20name%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A\"","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"query = \"\"\"\n        query consulta {\n          neomatrix {\n            nombre\n          }\n        }\n        query hola {\n          neomatrix {\n            nombre\n            linkedin\n          }\n        }\n        \"\"\"\nr = Queryclient(\"https://neomatrix.herokuapp.com/graphql\",\n                query,\n                getlink = true,\n                operationName = \"consulta\")","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"result:","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"\"https://neomatrix.herokuapp.com/graphql?query=query%20consulta%7B%0A%20%20neomatrix%7B%0A%20%20%20%20%20%20nombre%0A%20%20%20%7D%0A%7D%0Aquery%20hola%7B%0A%20%20neomatrix%7B%0A%20%20%20%20%20%20nombre%0A%20%20%20%20%20%20linkedin%0A%20%20%20%20%7D%0A%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20&operationName=consulta\"","category":"page"},{"location":"client/#Validating-query-1","page":"Client","title":"Validating query","text":"","category":"section"},{"location":"client/#","page":"Client","title":"Client","text":"It is possible to validate the query locally before sending the request, only basic validations are carried out.","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"query = \"\"\"\n        {\n          neomatrix{\n            nombre\n            linkedin\n          }\n        }\n        \"\"\"\nr = Queryclient(\"https://neomatrix.herokuapp.com/graphql\",query, check = true)","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"result:","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"\"ok\"","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":" query = \"\"\"\n         {\n         neomatrix {\n           nombre\n           linkedin\n         }\n\n         \"\"\"\nr = Queryclient(\"https://neomatrix.herokuapp.com/graphql\",query, true)\n#r = client.Query(query, check = true)","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"result:","category":"page"},{"location":"client/#","page":"Client","title":"Client","text":"ERROR: Diana.GraphQLError(\"{\\\"errors\\\":[{\\\"locations\\\": [{\\\"column\\\": 10,\\\"line\\\": 6}],\\\"message\\\": \\\"Syntax Error GraphQL request (10:6) Expected NAME, found eof \\\"}]}\")","category":"page"},{"location":"server/#Server-1","page":"Server","title":"Server","text":"","category":"section"},{"location":"server/#Schemas-and-Types-1","page":"Server","title":"Schemas and Types","text":"","category":"section"},{"location":"server/#Type-system-1","page":"Server","title":"Type system","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"If you've seen a GraphQL query before, you know that the GraphQL query language is basically about selecting fields on objects. So, for example, in the following query:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"{\n  neomatrix{\n  \tnombre\n  \tedad\n  }\n}","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"We start with a special \"root\" object\nWe select the neomatrix field on that\nFor the object returned by neomatrix, we select the nombre and edad fields","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Because the shape of a GraphQL query closely matches the result, you can predict what the query will return without knowing that much about the server. But it's useful to have an exact description of the data we can ask for - what fields can we select? What kinds of objects might they return? What fields are available on those sub-objects? That's where the schema comes in.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Every GraphQL service defines a set of types which completely describe the set of possible data you can query on that service. Then, when queries come in, they are validated and executed against that schema.","category":"page"},{"location":"server/#Object-types-and-fields-1","page":"Server","title":"Object types and fields","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"The most basic components of a GraphQL schema are object types, which just represent a kind of object you can fetch from your service, and what fields it has. In the GraphQL schema language, we might represent it like this:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"#schema-first\n\"\"\"\ntype Persona {\n  nombre: String\n  edad: Int!\n}\n\"\"\"\n\n# code-first\nDict(\"Persona\" => Dict(\n    \"nombre\"=>Dict(\"tipo\"=>\"String\")\n    ,\"edad\"=>Dict(\"tipo\"=>\"Int!\")\n  )\n)","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"The language is pretty readable, but let's go over it so that we can have a shared vocabulary:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Persona is a GraphQL Object Type, meaning it's a type with some fields. Most of the types in your schema will be object types.\nnombre and edad are fields on the Persona type. That means that nombre and edad are the only fields that can appear in any part of a GraphQL query that operates on the Persona type.\nString is one of the built-in scalar types - these are types that resolve to a single scalar object, and can't have sub-selections in the query. We'll go over scalar types more later.\nInt! means that the field is non-nullable, meaning that the GraphQL service promises to always give you a value when you query this field. In the type language, we'll represent those with an exclamation mark.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Now you know what a GraphQL object type looks like, and how to read the basics of the GraphQL type language.","category":"page"},{"location":"server/#Arguments-1","page":"Server","title":"Arguments","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"Every field on a GraphQL object type can have zero or more arguments, for example the edad field below:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"#schema-first\n\"\"\"\ntype Persona {\n  nombre: String\n  edad(valor:Int): Int!\n}\n\"\"\"\n\n# code-first\nDict(\"Persona\" => Dict(\n    \"nombre\"=>Dict(\"tipo\"=>\"String\")\n    ,\"edad\"=>Dict(\"tipo\"=>\"Int!\"\n      ,\"args\"=>Dict(\n        \"valor\"=>\"Int\")\n    )\n  )\n )","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"All arguments are named. Unlike languages like JavaScript and Python where functions take a list of ordered arguments, all arguments in GraphQL are passed by name specifically. In this case, the edad field has one defined argument, valor.","category":"page"},{"location":"server/#The-Query-and-Mutation-types-1","page":"Server","title":"The Query and Mutation types","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"Most types in your schema will just be normal object types, but there are two types that are special within a schema:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"#schema-first\n\"\"\"\nschema {\n  query: Query\n  mutation: Mutation\n}\n\"\"\"\n\n# code-first\nDict(\n\"query\" => Query #Dict()\n,\"mutation\" => Mutation #Dict()\n)","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Every GraphQL service has a query type and may or may not have a mutation type. These types are the same as a regular object type, but they are special because they define the entry point of every GraphQL query. So if you see a query that looks like:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"query{\n    neomatrix{\n    \tnombre\n    \taltura\n    }\n    persona(id:\"200\"){\n    \tnombre\n    \tedad\n    }\n}","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"That means that the GraphQL service needs to have a Query type with neomatrix and persona fields:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"#schema-first\n\"\"\"\ntype Query {\n  neomatrix: Persona\n  persona(id: ID!): Persona\n}\n\"\"\"\n\n# code-first\nDict(\n\"Query\"   => Dict(\n     \"neomatrix\"=>Dict(\"tipo\"=>\"Persona\")\n    ,\"persona\"=>Dict(\"tipo\"=>\"Persona\"\n      ,\"args\"=>Dict(\n        \"id\"=>\"ID!\")\n        )\n   )\n)","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Mutations work in a similar way - you define fields on the Mutation type, and those are available as the root mutation fields you can call in your query.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"It's important to remember that other than the special status of being the \"entry point\" into the schema, the Query and Mutation types are the same as any other GraphQL object type, and their fields work exactly the same way.","category":"page"},{"location":"server/#Scalar-types-1","page":"Server","title":"Scalar types","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"A GraphQL object type has a name and fields, but at some point those fields have to resolve to some concrete data. That's where the scalar types come in: they represent the leaves of the query.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"In the following query, the nombre and edad fields will resolve to scalar types:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"{\n  neomatrix{\n    nombre\n    edad\n  }\n}","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"We know this because those fields don't have any sub-fields - they are the leaves of the query.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"GraphQL comes with a set of default scalar types out of the box:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Int: A signed 64‐bit integer.\nFloat: A signed double-precision floating-point value.\nString: A UTF‐8 character sequence.\nBoolean: true or false.\nID: The ID scalar type represents a unique identifier, often used to refetch an object or as the key for a cache. The ID type is serialized in the same way as a String; however, defining it as an ID signifies that it is not intended to be human‐readable.","category":"page"},{"location":"server/#Input-types-1","page":"Server","title":"Input types","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"So far, we've only talked about passing scalar values as arguments into a field. But you can also easily pass complex objects. This is particularly valuable in the case of mutations, where you might want to pass in a whole object to be created. In the GraphQL schema language, input types look exactly the same as regular object types, but with the keyword input instead of type:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"# schema-first\n\"\"\"\ninput DataInputType{\n  nombre: String\n  edad: Int\n}\n\"\"\"\n\n# code-first\nDict(\n\"DataInputType\" => Dict(\n     \"nombre\"=>Dict(\"tipo\"=>\"String\")\n    ,\"edad\"=>Dict(\"tipo\"=>\"Int\")\n   )\n)","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Here is how you could use the input object type in a mutation:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"\nmutation mutationwithvariarbles(\\$dato: DataInputType){\n  addPerson(data: \\$dato ){\n    nombre,\n    edad\n  }\n}","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"The fields on an input object type can themselves refer to input object types, but you can't mix input and output types in your schema. Input object types also can't have arguments on their fields.","category":"page"},{"location":"server/#Queries-and-Mutations-1","page":"Server","title":"Queries and Mutations","text":"","category":"section"},{"location":"server/#Fields-1","page":"Server","title":"Fields","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"At its simplest, GraphQL is about asking for specific fields on objects. Let's start by looking at a very simple query and the result we get when we run it:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"{\n  persona {\n    nombre\n  }\n}","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"You can see immediately that the query has exactly the same shape as the result. This is essential to GraphQL, because you always get back what you expect, and the server knows exactly what fields the client is asking for.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"The field nombre returns a String type.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Oh, one more thing - the query above is interactive. That means you can change it as you like and see the new result. Try adding an edad field to the persona object in the query, and see the new result.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"In the previous example, we just asked for the nombre of our persona which returned a String, but fields can also refer to Objects. In that case, you can make a sub-selection of fields for that object. GraphQL queries can traverse related objects and their fields, letting clients fetch lots of related data in one request, instead of making several roundtrips as one would need in a classic REST architecture.","category":"page"},{"location":"server/#Arguments-2","page":"Server","title":"Arguments","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"If the only thing we could do was traverse objects and their fields, GraphQL would already be a very useful language for data fetching. But when you add the ability to pass arguments to fields, things get much more interesting.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"{\n  persona(id: \"1000\") {\n    nombre\n    altura\n  }\n}","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"In a system like REST, you can only pass a single set of arguments - the query parameters and URL segments in your request. But in GraphQL, every field and nested object can get its own set of arguments, making GraphQL a complete replacement for making multiple API fetches. You can even pass arguments into scalar fields, to implement data transformations once on the server, instead of on every client separately.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"{\n  persona(id: \"1000\") {\n    nombre\n    altura(unidad: String)\n  }\n}","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Arguments can be of many different types.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Read more about the GraphQL type system here.","category":"page"},{"location":"server/#Operation-name-1","page":"Server","title":"Operation name","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"Up until now, we have been using a shorthand syntax where we omit both the query keyword and the query name, but in production apps it's useful to use these to make our code less ambiguous.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Here’s an example that includes the keyword query as operation type and PersonaNombreandEdad as operation name :","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"\nquery PersonaNombreandEdad {\n  persona {\n    name\n    edad\n  }\n}","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"The operation type is either query, mutation, or subscription and describes what type of operation you're intending to do. The operation type is required unless you're using the query shorthand syntax, in which case you can't supply a name or variable definitions for your operation.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"The operation name is a meaningful and explicit name for your operation. It is only required in multi-operation documents, but its use is encouraged because it is very helpful for debugging and server-side logging. When something goes wrong either in your network logs or your GraphQL server, it is easier to identify a query in your codebase by name instead of trying to decipher the contents. Think of this just like a function name in your favorite programming language. For example, in JavaScript we can easily work only with anonymous functions, but when we give a function a name, it's easier to track it down, debug our code, and log when it's called. In the same way, GraphQL query and mutation names, along with fragment names, can be a useful debugging tool on the server side to identify different GraphQL requests.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"my_schema.execute(query, operationName=\"PersonaNombreandEdad\")","category":"page"},{"location":"server/#Variables-1","page":"Server","title":"Variables","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"So far, we have been writing all of our arguments inside the query string. But in most applications, the arguments to fields will be dynamic: For example, there might be a dropdown, or a search field, or a set of filters.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"It wouldn't be a good idea to pass these dynamic arguments directly in the query string, because then our client-side code would need to dynamically manipulate the query string at runtime, and serialize it into a GraphQL-specific format. Instead, GraphQL has a first-class way to factor dynamic values out of the query, and pass them as a separate dictionary. These values are called variables.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"When we start working with variables, we need to do three things:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Replace the static value in the query with \\$variableName\nDeclare \\$variableName as one of the variables accepted by the query\nPass variableName: value in the separate, transport-specific (JSON) variables dictionary","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Here's what it looks like all together:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"\nquery PersonaNombreandEdad(\\$identificador: ID) {\n  persona(id: \\$identificador) {\n    nombre\n    edad\n  }\n}","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Now, in our client code, we can simply pass a different variable rather than needing to construct an entirely new query. This is also in general a good practice for denoting which arguments in our query are expected to be dynamic - we should never be doing string interpolation to construct queries from user-supplied values.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"my_schema.execute(query,Variables=Dict(\"identificador\"=>\"100\"))","category":"page"},{"location":"server/#Variable-definitions-1","page":"Server","title":"Variable definitions","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"The variable definitions are the part that looks like (\\$identificador: ID) in the query above. It works just like the argument definitions for a function in a typed language. It lists all of the variables, prefixed by \\$, followed by their type, in this case ID.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"All declared variables must be either scalars, or input object types. So if you want to pass a complex object into a field, you need to know what input type that matches on the server. Learn more about input object types on the Schemas and Types seccion.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Variable definitions can be optional or required. In the case above, since there isn't an ! next to the ID type, it's optional. But if the field you are passing the variable into requires a non-null argument, then the variable has to be required as well.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"To learn more about the syntax for these variable definitions, it's useful to learn the GraphQL schema language. The schema language is explained in detail on the Schemas and Types seccion.","category":"page"},{"location":"server/#Mutations-1","page":"Server","title":"Mutations","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"Most discussions of GraphQL focus on data fetching, but any complete data platform needs a way to modify server-side data as well.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"In REST, any request might end up causing some side-effects on the server, but by convention it's suggested that one doesn't use GET requests to modify data. GraphQL is similar - technically any query could be implemented to cause a data write. However, it's useful to establish a convention that any operations that cause writes should be sent explicitly via a mutation.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"#schema-first\nschema = \"\"\"\ntype Persona {\n  nombre: String\n  edad: Int\n  altura: Float\n  spooilers:Boolean\n}\n type Query{\n  persona: Persona\n  neomatrix: Persona\n}\ntype Mutation{\n  addPerson(nombre:String,edad:Int): Persona\n}\n schema {\n  query: Query\n  mutation:Mutation\n}\n\"\"\"\n\n# code-first\nschema = Dict(\n\"query\" => \"Query\"\n,\"Query\"   => Dict(\n    \"persona\"=>Dict(\"tipo\"=>\"Persona\")\n     ,\"neomatrix\"=>Dict(\"tipo\"=>\"Persona\")\n   )\n,\"Persona\" => Dict(\n    \"edad\"=>Dict(\"tipo\"=>\"Int\")\n    ,\"nombre\"=>Dict(\"tipo\"=>\"String\")\n  )\n\n,\"mutation\" => \"Mutation\"\n,\"Mutation\" => Dict(\n\n    \"addPerson\"=>Dict(\n\n      \"args\"=>Dict(\n        \"nombre\"=>\"String\",\n        \"edad\"=>\"Int\")\n\n      ,\"tipo\"=>\"Persona\"\n\n      )\n\n  )\n)\n\n\nresolvers=Dict(\n    \"Query\"=>Dict(\n        \"neomatrix\" => (root,args,ctx,info)->(\n          return Dict(\"nombre\"=>\"josue\",\"edad\"=>25,\"altura\"=>10.5,\"spooilers\"=>false)\n          )\n        ,\"persona\" => (root,args,ctx,info)->(return Dict(\"nombre\"=>\"Diana\",\"edad\"=>14,\"altura\"=>11.8,\"spooilers\"=>true))\n    )\n    ,\"Persona\"=>Dict(\n      \"edad\" => (root,args,ctx,info)->(return root[\"edad\"])\n    )\n    ,\"Mutation\"=>Dict(\n        \"addPerson\" => (root,args,ctx,info)->(\n          return Dict(\"nombre\"=>args[\"nombre\"],\"edad\"=>args[\"edad\"],\"altura\"=>10.5,\"spooilers\"=>false)\n          )\n    )\n)\n\n\n my_schema = Schema(schema, resolvers)\n","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Just like in queries, if the mutation field returns an object type, you can ask for nested fields. This can be useful for fetching the new state of an object after an update. Let's look at a simple example mutation:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"my_schema.execute(\"\"\"\nmutation mutationwithvariables(\\$dato: DataInputType){\n  addPerson(data: \\$dato ){\n    nombre,\n    edad\n  }\n}\n\"\"\",Variables=Dict(\"dato\"=>Dict(\"edad\"=>20,\"nombre\"=>\"bob\")))\n#{\"data\":{\"addPerson\":{\"edad\":20,\"nombre\":\"bob\"}}}","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Note how addPerson field returns the nombre and edad fields of the newly created review. This is especially useful when mutating existing data, for example, when incrementing a field, since we can mutate and query the new value of the field with one request.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"You might also notice that, in this example, the data variable we passed in is not a scalar. It's an input object type, a special kind of object type that can be passed in as an argument. Learn more about input types on the Schemas and Types seccion.","category":"page"},{"location":"server/#Multiple-fields-in-mutations-1","page":"Server","title":"Multiple fields in mutations","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"A mutation can contain multiple fields, just like a query. There's one important distinction between queries and mutations, other than the name:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"While query fields are executed in parallel (in this version the execution is in series), mutation fields run in series, one after the other.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"This means that if we send two incrementCredits mutations in one request, the first is guaranteed to finish before the second begins, ensuring that we don't end up with a race condition with ourselves.","category":"page"},{"location":"server/#Execution-1","page":"Server","title":"Execution","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"After being validated, a GraphQL query is executed by a GraphQL server which returns a result that mirrors the shape of the requested query, as JSON.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"GraphQL cannot execute a query without a type system, let's use an example type system to illustrate executing a query. This is a part of the same type system used throughout the examples:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"#schema-first\n\"\"\"\ntype Persona {\n  nombre: String\n  edad: Int\n}\n type Query{\n  persona: Persona\n  neomatrix: Persona\n}\n\"\"\"\n\n# code-first\nschema = Dict(\n\"query\" => \"Query\"\n,\"Query\"   => Dict(\n    \"persona\"=>Dict(\"tipo\"=>\"Persona\")\n     ,\"neomatrix\"=>Dict(\"tipo\"=>\"Persona\")\n   )\n,\"Persona\" => Dict(\n    \"edad\"=>Dict(\"tipo\"=>\"Int\")\n    ,\"nombre\"=>Dict(\"tipo\"=>\"String\")\n  )\n)\n\n","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"In order to describe what happens when a query is executed, let's use an example to walk through.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"query{\n  neomatrix{\n  \tnombre\n  }\n}","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"You can think of each field in a GraphQL query as a function or method of the previous type which returns the next type. In fact, this is exactly how GraphQL works. Each field on each type is backed by a function called the resolver which is provided by the GraphQL server developer. When a field is executed, the corresponding resolver is called to produce the next value.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"If a field produces a scalar value like a string or number, then the execution completes. However if a field produces an object value then the query will contain another selection of fields which apply to that object. This continues until scalar values are reached. GraphQL queries always end at scalar values.","category":"page"},{"location":"server/#Root-fields-and-resolvers-1","page":"Server","title":"Root fields & resolvers","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"At the top level of every GraphQL server is a type that represents all of the possible entry points into the GraphQL API, it's often called the Root type or the Query type.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"In this example, our Query type provides a field called persona which accepts the argument nombre. The resolver function for this field likely accesses a database and then constructs and returns a Persona object.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"resolvers=Dict(\n    \"Query\"=>Dict(\n        \"neomatrix\" => (root,args,ctx,info)->(\n        \treturn Dict(\"nombre\"=>\"josue\",\"edad\"=>25,\"altura\"=>10.5,\"spooilers\"=>false)\n        \t)\n        ,\"persona\" => (root,args,ctx,info)->(\n        \treturn Dict(\"nombre\"=>\"Diana\",\"edad\"=>14,\"altura\"=>11.8,\"spooilers\"=>true)\n        \t)\n    )\n)","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"A resolver function receives four arguments:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"root The previous object, which for a field on the root Query type is often not used.\nargs The arguments provided to the field in the GraphQL query.\ncontext A value which is provided to every resolver and holds important contextual information like the currently logged in user, or access to a database.\ninfo A value which holds field-specific information relevant to the current query as well as the schema details.","category":"page"},{"location":"server/#Context-1","page":"Server","title":"Context","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"The context variable is used to pass data between the resolvers or to store global variables, its value is defined when creating the scheme","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":" my_schema = Schema(schema, resolvers, context=Dict(\"data\"=>\"datacontext\"))","category":"page"},{"location":"server/#Trivial-resolvers-1","page":"Server","title":"Trivial resolvers","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"Now that a Persona object is available, GraphQL execution can continue with the fields requested on it.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"resolvers=Dict(\n    \"Query\"=>Dict(\n        \"neomatrix\" => (root,args,ctx,info)->(\n        \treturn Dict(\"nombre\"=>\"josue\",\"edad\"=>25,\"altura\"=>10.5,\"spooilers\"=>false)\n        \t)\n        ,\"persona\" => (root,args,ctx,info)->(\n        \treturn Dict(\"nombre\"=>\"Diana\",\"edad\"=>14,\"altura\"=>11.8,\"spooilers\"=>true)\n        \t)\n    )\n    ,\"Persona\"=>Dict(\n      \"edad\" => (root,args,ctx,info)->(\n      \treturn root[\"edad\"])\n    )\n)","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"A GraphQL server is powered by a type system which is used to determine what to do next. Even before the persona field returns anything, GraphQL knows that the next step will be to resolve fields on the Persona type since the type system tells it that the persona field will return a Persona.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Resolving age in this case is very straight-forward. The name resolver function is called and the root argument is the new Persona object returned from the previous field. In this case, we expect that Human object to have a edad property which we can read and return directly.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"In fact, Diana will allow you to skip resolvers that simple and will simply assume that if a resolver is not provided for a field, a property of the same name must be read and returned","category":"page"},{"location":"server/#Producing-the-result-1","page":"Server","title":"Producing the result","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"As each field is resolved, the resulting value is placed into a dictionary with the field name as the key and the resolved value as the value, this continues from the bottom leaf fields of the query all the way back up to the original field on the root Query type. Collectively these produce a structure that mirrors the original query which can then be sent (JSON) to the client which requested it.","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"Let's take one last look at the original query to see how all these resolving functions produce a result:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"{\n  persona{\n    nombre\n  }\n}","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"result:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"{\"datos\":{\n  \"persona\":{\n    \"nombre\":\"Diana\"\n    }\n  }\n}","category":"page"},{"location":"server/#Tools-1","page":"Server","title":"Tools","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"Diana provides the Parser and the Lexer of the graphql for anyone to create their own tools and implementations","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"The lexer is built based on the Tokenize package code and the Parser on the graphql-js package. Thanks people.","category":"page"},{"location":"server/#Parser-1","page":"Server","title":"Parser","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"using Diana\n\nParse(\"\"\"\n      #\n      query {\n        Region(name: \"The North\") {\n          NobleHouse(name: \"Stark\") {\n            castle {\n              name\n            }\n            members{\n              name\n              alias\n            }\n          }\n        }\n      }\n      \"\"\")","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"result:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":" < Node :: Document ,definitions : Diana.Node[\n < Node :: OperationDefinition ,operation : query ,selectionSet :\n < Node :: SelectionSet ,selections : Diana.Node[\n < Node :: Field ,name :\n < Node :: Name ,value : Region >  ,arguments : Diana.Argument[\n < Node :: Argument ,name :\n < Node :: Name ,value : name >  ,value : (\":\",\n < Node :: StringValue ,value : The North > ) > ] ,selectionSet :\n < Node :: SelectionSet ,selections : Diana.Node[\n < Node :: Field ,name :\n < Node :: Name ,value : NobleHouse >  ,arguments : Diana.Argument[\n < Node :: Argument ,name :\n < Node :: Name ,value : name >  ,value : (\":\",\n < Node :: StringValue ,value : Stark > ) > ] ,selectionSet :\n < Node :: SelectionSet ,selections : Diana.Node[\n < Node :: Field ,name :\n < Node :: Name ,value : castle >  ,selectionSet :\n < Node :: SelectionSet ,selections : Diana.Node[\n < Node :: Field ,name :\n < Node :: Name ,value : name >  > ] >  > ,\n < Node :: Field ,name :\n < Node :: Name ,value : members >  ,selectionSet :\n < Node :: SelectionSet ,selections : Diana.Node[\n < Node :: Field ,name :\n < Node :: Name ,value : name >  > ,\n < Node :: Field ,name :\n < Node :: Name ,value : alias >  > ] >  > ] >  > ] >  > ] >  > ] >","category":"page"},{"location":"server/#Lexer-1","page":"Server","title":"Lexer","text":"","category":"section"},{"location":"server/#","page":"Server","title":"Server","text":"using Diana\n\nTokensgraphql(\"\"\"\n              #\n              query {\n                Region(name: \"The North\") {\n                  NobleHouse(name: \"Stark\") {\n                    castle {\n                      name\n                    }\n                    members {\n                      name\n                      alias\n                    }\n                  }\n                }\n              }\n              \"\"\")","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"result:","category":"page"},{"location":"server/#","page":"Server","title":"Server","text":"29-element Array{Diana.Tokens.Token,1}:\n NAME           query               2,15 - 2,19\n LBRACE         {                   2,21 - 2,21\n NAME           Region              3,31 - 3,36\n LPAREN         (                   3,37 - 3,37\n NAME           name                3,38 - 3,41\n COLON          :                   3,42 - 3,42\n STRING         The North           3,44 - 3,54\n RPAREN         )                   3,55 - 3,55\n LBRACE         {                   3,57 - 3,57\n NAME           NobleHouse          4,49 - 4,58\n LPAREN         (                   4,59 - 4,59\n NAME           name                4,60 - 4,63\n COLON          :                   4,64 - 4,64\n STRING         Stark               4,66 - 4,72\n RPAREN         )                   4,73 - 4,73\n LBRACE         {                   4,75 - 4,75\n NAME           castle              5,69 - 5,74\n LBRACE         {                   5,76 - 5,76\n NAME           name                6,91 - 6,94\n RBRACE         }                   7,111 - 7,111\n NAME           members             8,131 - 8,137\n LBRACE         {                   8,139 - 8,139\n NAME           name                9,153 - 9,156\n NAME           alias               10,175 - 10,179\n RBRACE         }                   11,195 - 11,195\n RBRACE         }                   12,213 - 12,213\n RBRACE         }                   13,229 - 13,229\n RBRACE         }                   14,243 - 14,243\n ENDMARKER                          15,257 - 15,257","category":"page"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#Getting-Started-1","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"GraphQL is a query language for API created by Facebook. See more complete documentation at http://graphql.org/. Looking for help? Find resources from the community.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"An overview of GraphQL in general is available in the README for the Specification for GraphQL.","category":"page"},{"location":"#Diana.jl-1","page":"Home","title":"Diana.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Diana is a library that provides tools to implement a GraphQL API in Julia using both the code-first like Graphene (Python) approach and the schema-first like Ariadne (Python). Diana produces schemas that are fully compliant with the GraphQL spec.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package is intended to help you building GraphQL schemas/types fast and easily.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Easy to use: Diana.jl helps you use GraphQL in Julia without effort.\nData agnostic: Diana.jl supports any type of data source: SQL, NoSQL, etc. The intent is to provide a complete API and make your data available through GraphQL.\nMake queries: Diana.jl allows queries to graphql schemas.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pkg> add Diana\n#Release\npkg> add Diana#master\n#Development","category":"page"},{"location":"#An-example-in-Diana-1","page":"Home","title":"An example in Diana","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Let’s build a basic GraphQL schema to say “hello” and “goodbye” in Diana.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Diana\n\nschema = Dict(\n\"query\" => \"Query\"\n,\"Query\"   => Dict(\n    \"hello\"=>Dict(\"tipo\"=>\"String\")\n   ,\"goodbye\"=>Dict(\"tipo\"=>\"String\")\n   )\n)\n\nresolvers=Dict(\n    \"Query\"=>Dict(\n        \"hello\" => (root,args,ctx,info)->(return \"Hello World!\")\n        ,\"goodbye\" => (root,args,ctx,info)->(return \"Goodbye World\")\n    )\n)\n\nmy_schema = Schema(schema, resolvers)\n","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For each Field in our Schema, we write a Resolver method to fetch data requested by a client’s Query using the current context and Arguments.","category":"page"},{"location":"#Schema-Definition-Language-(SDL)-1","page":"Home","title":"Schema Definition Language (SDL)","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In the GraphQL Schema Definition Language, we could describe the fields defined by our example code as show below.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Diana\n\n schema= \"\"\"\n type Query{\n  hello: String\n  goodbye: String\n}\n schema {\n  query: Query\n}\n\"\"\"\n\nresolvers=Dict(\n    \"Query\"=>Dict(\n        \"hello\" => (root,args,ctx,info)->(return \"Hello World!\")\n        ,\"goodbye\" => (root,args,ctx,info)->(return \"Goodbye World\")\n    )\n)\n\nmy_schema = Schema(schema, resolvers)\n","category":"page"},{"location":"#Querying-1","page":"Home","title":"Querying","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Then we can start querying our Schema by passing a GraphQL query string to execute:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"query= \"\"\"\nquery{\n  hello\n}\n\"\"\"\n\nresult = my_schema.execute(query)\n\nprintln(result)\n# {\"data\":{\"hello\":\"Hello World!\"}}","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Congrats! You got your first Diana schema working!","category":"page"},{"location":"#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"client.md\",\"server.md\"]\nDepth = 5","category":"page"},{"location":"#Functions-1","page":"Home","title":"Functions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Tokensgraphql(x::String)\nParse(str::String)\nQueryclient(queryurl::String)\nQueryclient(url::String,data::String; vars::Dict=Dict(),auth::String=\"Bearer 0000\", headers::Dict=Dict(),getlink::Bool=false,check::Bool=false,operationName::String=\"\")\nGraphQLClient(url::String; auth::String=\"Bearer 0000\", headers::Dict=Dict())\nSchema(_schema::String, resolvers::Dict; context=nothing)\nSchema(_schema::Dict, resolvers::Dict; context=nothing)","category":"page"},{"location":"#Diana.Tokensgraphql-Tuple{String}","page":"Home","title":"Diana.Tokensgraphql","text":"Tokensgraphql(x::String)\n\nGiven an origin string, this returns the set of tokens that make up that source.\n\n\n\n\n\n","category":"method"},{"location":"#Diana.Parse-Tuple{String}","page":"Home","title":"Diana.Parse","text":"Parse(str::String)\n\nGiven a GraphQL source, parses it into a AST. Throws Diana.GraphQLError if a syntax error is encountered.\n\n\n\n\n\n","category":"method"},{"location":"#Diana.Queryclient-Tuple{String}","page":"Home","title":"Diana.Queryclient","text":"Queryclient(queryurl::String)\n\nExecute the query in link format and return the result.\n\n\n\n\n\n","category":"method"},{"location":"#Diana.Queryclient-Tuple{String,String}","page":"Home","title":"Diana.Queryclient","text":"Queryclient(url::String,data::String; vars::Dict=Dict(),auth::String=\"Bearer 0000\", headers::Dict=Dict(),getlink::Bool=false,check::Bool=false,operationName::String=\"\")\n\nExecute a query with all available parameters\n\n\n\n\n\n","category":"method"},{"location":"#Diana.GraphQLClient-Tuple{String}","page":"Home","title":"Diana.GraphQLClient","text":"GraphQLClient(url::String; auth::String=\"Bearer 0000\", headers::Dict=Dict())\n\nStores the parameters of the query for later use, returns a Client object\n\n\n\n\n\n","category":"method"},{"location":"#Diana.Schema-Tuple{String,Dict}","page":"Home","title":"Diana.Schema","text":"Schema(_schema::String, resolvers::Dict; context=nothing)\n\nReceive a schema in string format or in a text file, return an object of type schema\n\n\n\n\n\n","category":"method"},{"location":"#Diana.Schema-Tuple{Dict,Dict}","page":"Home","title":"Diana.Schema","text":"Schema(_schema::Dict, resolvers::Dict; context=nothing)\n\nReceive a schema in dictionary format, return an object of type schema\n\n\n\n\n\n","category":"method"},{"location":"#Index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"}]
}
